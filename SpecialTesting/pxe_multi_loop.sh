#!/bin/bash
# This script processes the logs generated by the PXE loop.
# Written By: Kelly Cantrell

# === CONFIGURATION ===
USER="XXX"
PASSWORD="YYY"
DESTINATION_PATH="/tmp"
LOG_DIR="./pxe_logs"
CONTROLLER_IP="10.1.1.1"
GLOBAL_START_TIME=$(date +%s)
MAX_RUNTIME=$((150 * 60))

# Set IP's
declare -A SERVERS=(
  [Server1]="10.1.1.1"
  [Server2]="10.1.1.1"
  [Server3]="10.1.1.1"
  [Server4]="10.1.1.1"
  [Server5]="10.1.1.1"
  [Server6]="10.1.1.1"
  [Server7]="10.1.1.1"
  [Server8]="10.1.1.1"
  [Server9]="10.1.1.1"
)

# === Start tcpdump in background ===
TCPDUMP_SCRIPT="./tcpdump_pxe.sh"
bash "$TCPDUMP_SCRIPT" &
TCPDUMP_PID=$!

# === Start iperf3 server tied to script lifecycle ===
iperf3 -s > /dev/null 2>&1 &
IPERF_PID=$!

# === Close iPerf and tcpdump on script exit === ISSUE: PID Changes between loops
#trap "kill $TCPDUMP_PID" EXIT
#trap "kill $IPERF_PID" EXIT

# === Create Log Directory for Test ===
mkdir -p "$LOG_DIR"

# === Function for Logging Data ===
log() {
    local server="$1"
    local msg="$2"
    local logfile="$LOG_DIR/${server}.log"
    echo "[$(date '+%F %T')] $msg" | tee -a "$logfile"
}

# === Main Function ===
process_server() {
    local name="$1"
    local ip="${SERVERS[$name]}"
    local logfile="$LOG_DIR/${name}.log"
    local FILE_TO_COPY="/home/kelly.cantrell/transfer_files/${name}_file"

    # === Initial Check ===
    if [ ! -f "$FILE_TO_COPY" ]; then
      log "$name" "‚ùå File not found: $FILE_TO_COPY"
      return
    fi

    # === Start iPerf for Server 9 === 
    if [[ "$name" == "Server9" ]]; then
    local start_time="$GLOBAL_START_TIME"
    local max_runtime="$MAX_RUNTIME"
        while true; do
            local current_time=$(date +%s)
            local elapsed_time=$((current_time - start_time))
            if (( elapsed_time >= max_runtime )); then
                log "$name" "‚èπÔ∏è Reached max runtime of 2.5 hour. Exiting iPerf loop."
                break
            fi
            log "$name" "üì∂ Starting continuous iperf3 tests for $name"
            if [[ -z "$ip" ]]; then
                log "$name" "‚ùå Could not resolve IP for iperf3. Retrying..."
                sleep 10
                continue
            fi
            log "$name" "‚úÖ Resolved IP: $ip"
            log "$name" "üì° Pinging $ip..."
            if ! ping -c 1 "$ip" &>/dev/null; then
                log "$name" "‚è≥ $ip not reachable, retrying in 5s..."
                sleep 5
                continue
            fi
            log "$name" "‚úÖ $ip is reachable."
            iperf_output=$(sshpass -p "$PASSWORD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5 "$USER@$ip" "iperf3 -c $CONTROLLER_IP -t 10 2>&1")
            log "$name" "$iperf_output"
            sleep 30
            log "$name" "==========================================================================="
        done
        return
    fi

    # === Set Vars for Test Duration ===
    local cycle_count=0
    local max_cycles=30
    local start_time="$GLOBAL_START_TIME"
    local max_runtime="$MAX_RUNTIME"

    # === Log the DHCP State at the Beginning of Test ===
    sudo mkdir -p ./dhcp_logs
    sudo journalctl -u isc-dhcp-server > "/home/kelly.cantrell/dhcp_logs/$(date '+%Y-%m-%d_%H-%M-%S')_dhcp.log"

    # === Set the loop to run while less than the target ===
    while true; do
        local current_time=$(date +%s)
        local elapsed_time=$((current_time - start_time))
        local cycle_start=$(date +%s)


        if (( elapsed_time >= max_runtime )); then
            log "$name" "‚èπÔ∏è Reached max runtime of 2.5 hour. Exiting."
            break
        fi

        if (( cycle_count >= max_cycles )); then
            log "$name" "‚úÖ Reached max cycles ($max_cycles). Exiting."
            break
        fi

        sleep 5 # Lower CPU Load
        log "$name" "==========================================================================="
        log "$name" "üöÄ Starting PXE operation for $name (IP: $ip)"
        log "$name" "üï∞Ô∏è Cycle = $((cycle_count + 1))"

        # === Resolve IP ===
        if [ -z "$ip" ]; then
            log "$name" "‚ùå Could not find target IP. Retrying..."
            continue
        fi

        # === Check IP is Reachable === 
        log "$name" "‚úÖ Target IP: $ip"
        log "$name" "üì° Pinging $ip..."
        until ping -c 1 "$ip" &>/dev/null; do
            log "$name" "‚è≥ $ip not reachable yet..."
            sleep 5
        done
        log "$name" "‚úÖ $ip is reachable."

        # === Attempt SSH ===
        log "$name" "üîê Trying SSH login..."
        until sshpass -p "$PASSWORD" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5 "$USER@$ip" "echo SSH OK" &>/dev/null; do
            log "$name" "üîÑ SSH login failed, retrying..."
            sleep 5
        done
        log "$name" "‚úÖ SSH login successful."

        # === Collect Data for Rsync ===
        file_size_bytes=$(stat -c%s "$FILE_TO_COPY")
        file_size_mb=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / (1024*1024)}")
        file_size_gb=$(awk "BEGIN {printf \"%.2f\", $file_size_bytes / (1024*1024*1024)}")

        # === Start Rsync Process === 
        log "$name" "üìÅ Copying ${file_size_gb} GB to $ip:$DESTINATION_PATH using rsync..."
        local start_time_rsync=$(date +%s)
        RSYNC_RSH="ssh -o StrictHostKeyChecking=no -o -o UserKnownHostsFile=/dev/null ConnectTimeout=20"
        sshpass -p "$PASSWORD" rsync -av --inplace --progress --timeout=60 -e "$RSYNC_RSH" "$FILE_TO_COPY" "$USER@$ip:$DESTINATION_PATH/" &>>"$logfile"
        local status=$?
        local end_time_rsync=$(date +%s)
        local file_transfer_time=$((end_time_rsync - start_time_rsync))

        local speed_mbps
        speed_mbps=$(awk "BEGIN {if ($file_transfer_time > 0) printf \"%.2f\", $file_size_mb / $file_transfer_time; else print \"N/A\"}")
        log "$name" "‚úÖ File copied in ${file_transfer_time}s @ ${speed_mbps} MB/s"

        if [ $status -ne 0 ]; then # Catches all fail codes
            log "$name" "‚ùå Rsync failed. Retrying next cycle..."
        fi

        # === Reboot the Unit ===
        log "$name" "üîÑ Sending reboot..."
        sshpass -p "$PASSWORD" ssh -o StrictHostKeyChecking=no "$USER@$ip" "nohup reboot --force >/dev/null 2>&1 & exit"

        local reboot_start_time=$(date +%s)
        log "$name" "üïê Waiting for server to come back online..."
        sleep 120
        until ping -c1 "$ip" &>/dev/null; do
            sleep 1
        done
        log "$name" "‚è∞ Server back online..."
        sleep 15  # Give it time to settle

        local reboot_end_time=$(date +%s)
        local boot_time=$((reboot_end_time - reboot_start_time))
        local cycle_end=$(date +%s)
        local total_cycle_time=$((cycle_end - cycle_start))

        log "$name" "------------------"
        log "$name" "Completed Cycle $((cycle_count + 1))"
        log "$name" "Time to Reboot = ${boot_time}s"
        log "$name" "File Transfer Time = ${file_transfer_time}s"
        log "$name" "Total Cycle Time = ${total_cycle_time}s"

        # === Increase the Loop # ===
        ((cycle_count++))
        sleep 10 # Reduce CPU Load

    done
}

# === Start All Servers in Parallel ===
for server in "${!SERVERS[@]}"; do
    process_server "$server" &
done

wait
